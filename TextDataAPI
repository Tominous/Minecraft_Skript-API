# +-----------------------------------------+
# +------------- TEST COMMAND --------------+
# +-----------------------------------------+

# Command is not part of API
# Command is not part of API
# Command is not part of API

# This is a example of how the api could
# save different types of variable with text
# and convert them back to the object.

command /example:
	trigger:
		set {_player} to ("2bbd185f-8124-4339-b5ae-db9a4c614fd5" parsed as offline player)
		set {_location} to location at (1, 2, 3) in world("world")
		set {_objects::*} to ("Hello World: This is text, and he's cute!") and (3.14) and ({_location}) and ({_player}) and (true) and (stone)
		broadcast "&aINPUT: %{_objects::*}%"
		set {_dataString} to textData_objectsToString({_objects::*})
		broadcast "&eDATA TEXT: %{_dataString}%"
		set {_newDatas::*} to textData_stringToObjects({_dataString})
		broadcast "&cRESULT: %{_newDatas::*}%"

# +-----------------------------------------+
# +---------- API CODE START BELOW ---------+
# +-----------------------------------------+

function textData_objectsToString(objects: objects) :: text:
	if (amount of {_objects::*}) <= 0:
		stop # return nothing
	set {_return} to textData_system_objectConvertString({_objects::1})
	loop ((amount of {_objects::*}) - 1) times:
		set {_loopObjectNumber} to (loop-number + 1)
		set {_return} to "%{_return}%:%textData_system_objectConvertString({_objects::%{_loopObjectNumber}%})%"
	return {_return}

function textData_stringToObjects(dataText: text) :: objects:
	set {_datas::*} to textData_system_splitDatas({_dataText}, ":")
	loop {_datas::*}:
		add textData_system_stringConvertObject({_datas::%loop-index%}) to {_returnObjects::*}
	return {_returnObjects::*}

function textData_system_objectConvertString(dataObject: object) :: text:
	if {_dataObject} is a text:
		return "text[%textData_system_convertString({_dataObject})%]"
	else if {_dataObject} is a number:
		return "number[%{_dataObject}%]"
	else if {_dataObject} is a boolean:
		return "boolean[%{_dataObject}%]"
	else if {_dataObject} is a player or offline player:
		return "player[%{_dataObject}'s UUID%]"
	else if {_dataObject} is a location:
		set {_locationWorld} to "%{_dataObject}'s world%"
		set {_worldName} to textData_system_convertString({_locationWorld})
		return "location[%{_worldName}%, %{_dataObject}'s x coords%, %{_dataObject}'s y coords%, %{_dataObject}'s z coords%, %{_dataObject}'s yaw%, %{_dataObject}'s pitch%]"
	else if {_dataObject} is a item type:
		return "itemType[%{_dataObject}%]"
	else:
		return "unknown[]"

function textData_system_stringConvertObject(dataText: text) :: object:
	set {_split::*} to {_dataText} split by "["
	set {_objectType} to {_split::1}
	set {_split::*} to {_split::2} split by ""
	set {_deleteCharNumber} to ((amount of {_split::*}) - 1)
	delete {_split::%{_deleteCharNumber}%}
	set {_objectData} to join {_split::*} with ""
	if {_objectType} is "text":
		return textData_system_translateString({_objectData})
	else if {_objectType} is "number":
		return ({_objectData} parsed as number)
	else if {_objectType} is "boolean":
		if {_objectData} is "true":
			return true
		else if {_objectData} is "false":
			return false
	else if {_objectType} is "player":
		if ({_objectData} parsed as offline player) is online:
			return ({_objectData} parsed as player)
		else:
			return ({_objectData} parsed as offline player)
	else if {_objectType} is "location":
		set {_locationDatas::*} to textData_system_splitDatas({_objectData}, ",", true)
		loop 5 times:
			set {_parseNumberIndex} to (loop-number + 1)
			set {_locationDatas::%{_parseNumberIndex}%} to ({_locationDatas::%{_parseNumberIndex}%} parsed as number)
		set {_returnLocation} to location at ({_locationDatas::2}, {_locationDatas::3}, {_locationDatas::4}) in world({_locationDatas::1})
		set {_returnLocation}'s yaw to {_locationDatas::5}
		set {_returnLocation}'s pitch to {_locationDatas::6}
		return {_returnLocation}
	else if {_objectType} is "itemType":
		return ({_objectData} parsed as item)

function textData_system_convertString(text: text) :: text:
	set {_stringSplit::*} to {_text} split by ""
	loop {_stringSplit::*}:
		if textData_system_checkIllegalCharacters({_stringSplit::%loop-index%}) is true:
			set {_stringSplit::%loop-index%} to "\%{_stringSplit::%loop-index%}%"
	set {_final} to join {_stringSplit::*} with ""
	return {_final}

function textData_system_translateString(text: text) :: text:
	set {_stringSplit::*} to {_text} split by ""
	set {_loopNumber} to 0
	set {_loopTimes} to (amount of {_stringSplit::*})
	while {_loopNumber} <= {_loopTimes}:
		add 1 to {_loopNumber}
		set {_nextLoopNumber} to ({_loopNumber} + 1)
		set {_illegalCharCheck} to true
		if {_stringSplit::%{_loopNumber}%} is not "\":
			set {_illegalCharCheck} to false
		else if textData_system_checkIllegalCharacters({_stringSplit::%{_nextLoopNumber}%}) is false:
			set {_illegalCharCheck} to false
		if {_illegalCharCheck} is true:
			delete {_stringSplit::%{_loopNumber}%}
			add 1 to {_loopNumber}
	set {_final} to join {_stringSplit::*} with ""
	return {_final}

function textData_system_splitDatas(dataText: text, splitChar: text, removeCharAfter: boolean = false) :: texts:
	set {_dataTextSplit::*} to {_dataText} split by ""
	set {_splitString} to ""
	loop (amount of {_dataTextSplit::*}) times:
		set {_isSplit} to true
		set {_lastSplitNumber} to (loop-number - 1)
		if {_dataTextSplit::%loop-number%} is not {_splitChar}:
			set {_isSplit} to false
		else if {_dataTextSplit::%{_lastSplitNumber}%} is "\":
			set {_isSplit} to false
		if {_isSplit} is true:
			add {_splitString} to {_returnTexts::*}
			set {_splitString} to ""
			if {_removeCharAfter} is true:
				set {_ignoreNextChar} to true
		else:
			if {_ignoreNextChar} is true:
				set {_ignoreNextChar} to false
			else:
				set {_splitString} to "%{_splitString}%%{_dataTextSplit::%loop-number%}%"
	add {_splitString} to {_returnTexts::*} 
	return {_returnTexts::*}

function textData_system_checkIllegalCharacters(char: text) :: boolean:
	if {_char} is "\" or ":" or "[" or "]" or ",":
		return true
	return false
